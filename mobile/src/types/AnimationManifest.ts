/**
 * Animation Manifest Types
 *
 * Type definitions for the animation manifest generated by the pipeline.
 * Manifest location: output/manifest.json
 */

export interface AnimationManifest {
  /** Manifest format version (semver) */
  version: string;

  /** UTC timestamp when manifest was generated */
  generated_at: string;

  /** Total number of exercises in manifest */
  total_exercises: number;

  /** CDN base URL (optional) */
  cdn_base_url?: string;

  /** Per-exercise animation metadata */
  exercises: {
    [slug: string]: ExerciseAnimationMetadata;
  };

  /** Aggregate statistics */
  statistics: ManifestStatistics;
}

export interface ExerciseAnimationMetadata {
  /** Unique exercise identifier */
  slug: string;

  /** Human-readable exercise name */
  name: string;

  /** Movement pattern category */
  movement_pattern: MovementPattern;

  /** Camera angle in degrees (0, 45, 90, 135) */
  camera_angle: number;

  /** WebP animation metadata (if available) */
  webp?: AnimationFileMetadata;

  /** Lottie animation metadata (if available) */
  lottie?: AnimationFileMetadata;
}

export interface AnimationFileMetadata {
  /** Local file path (relative to project root) */
  path: string;

  /** CDN URL (if cdn_base_url provided) */
  url?: string;

  /** File size in bytes */
  file_size_bytes: number;

  /** File size in kilobytes (rounded to 1 decimal) */
  file_size_kb: number;

  /** Animation format */
  format: 'webp' | 'lottie';

  /** Number of frames (WebP only) */
  frame_count?: number;
}

export interface ManifestStatistics {
  /** Total number of exercises */
  total_exercises: number;

  /** Number of WebP animations */
  webp_count: number;

  /** Number of Lottie animations */
  lottie_count: number;

  /** Total size of all WebP files in MB */
  total_webp_size_mb: number;

  /** Total size of all Lottie files in MB */
  total_lottie_size_mb: number;

  /** Total frames across all WebP animations */
  total_frames: number;

  /** Average frames per WebP animation */
  avg_frames_per_animation: number;

  /** Distribution of exercises by movement pattern */
  movement_patterns: {
    [pattern: string]: number;
  };

  /** Distribution of exercises by camera angle */
  camera_angles: {
    [angle: number]: number;
  };

  /** WebP file size statistics */
  webp_stats?: FileStatistics;

  /** Lottie file size statistics */
  lottie_stats?: FileStatistics;
}

export interface FileStatistics {
  /** Minimum file size in KB */
  min_size_kb: number;

  /** Maximum file size in KB */
  max_size_kb: number;

  /** Average file size in KB */
  avg_size_kb: number;
}

export type MovementPattern =
  | 'push'
  | 'pull'
  | 'squat'
  | 'hip_hinge'
  | 'lunge'
  | 'rotation'
  | 'anti-rotation'
  | 'anti-extension'
  | 'locomotion'
  | 'plyometric'
  | 'full_body'
  | 'carry'
  | 'unknown';

/**
 * Helper function to load and parse manifest from CDN
 *
 * @param cdnBaseUrl - CDN base URL
 * @returns Parsed manifest
 *
 * @example
 * const manifest = await loadManifest('https://cdn.intensely.app');
 * console.log(`Total exercises: ${manifest.total_exercises}`);
 */
export async function loadManifest(
  cdnBaseUrl: string = process.env.EXPO_PUBLIC_CDN_BASE_URL || 'https://cdn.intensely.app'
): Promise<AnimationManifest> {
  const manifestUrl = `${cdnBaseUrl}/animations/manifest.json`;

  try {
    const response = await fetch(manifestUrl);

    if (!response.ok) {
      throw new Error(`Failed to load manifest: ${response.status} ${response.statusText}`);
    }

    const manifest: AnimationManifest = await response.json();
    return manifest;
  } catch (error) {
    console.error('Failed to load animation manifest:', error);
    throw error;
  }
}

/**
 * Helper function to get animation metadata for a specific exercise
 *
 * @param manifest - Animation manifest
 * @param slug - Exercise slug
 * @returns Animation metadata or undefined
 *
 * @example
 * const pushUpMeta = getExerciseAnimation(manifest, 'push-up');
 * if (pushUpMeta?.webp) {
 *   console.log(`WebP URL: ${pushUpMeta.webp.url}`);
 *   console.log(`Frames: ${pushUpMeta.webp.frame_count}`);
 * }
 */
export function getExerciseAnimation(
  manifest: AnimationManifest,
  slug: string
): ExerciseAnimationMetadata | undefined {
  return manifest.exercises[slug];
}

/**
 * Helper function to get all exercises with a specific movement pattern
 *
 * @param manifest - Animation manifest
 * @param pattern - Movement pattern to filter by
 * @returns Array of exercise metadata
 *
 * @example
 * const pushExercises = getExercisesByPattern(manifest, 'push');
 * console.log(`Found ${pushExercises.length} push exercises`);
 */
export function getExercisesByPattern(
  manifest: AnimationManifest,
  pattern: MovementPattern
): ExerciseAnimationMetadata[] {
  return Object.values(manifest.exercises).filter(
    (exercise) => exercise.movement_pattern === pattern
  );
}

/**
 * Helper function to check if animations need updating
 *
 * Compares local manifest version with CDN manifest version.
 *
 * @param localManifest - Local cached manifest
 * @param cdnBaseUrl - CDN base URL
 * @returns True if update available
 *
 * @example
 * const needsUpdate = await checkForUpdates(cachedManifest);
 * if (needsUpdate) {
 *   const newManifest = await loadManifest();
 *   // Update local cache
 * }
 */
export async function checkForUpdates(
  localManifest: AnimationManifest,
  cdnBaseUrl?: string
): Promise<boolean> {
  try {
    const cdnManifest = await loadManifest(cdnBaseUrl);

    // Compare versions
    if (cdnManifest.version !== localManifest.version) {
      return true;
    }

    // Compare generation timestamps
    const localTime = new Date(localManifest.generated_at).getTime();
    const cdnTime = new Date(cdnManifest.generated_at).getTime();

    return cdnTime > localTime;
  } catch (error) {
    console.error('Failed to check for manifest updates:', error);
    return false;
  }
}

/**
 * Helper function to get preferred animation format for an exercise
 *
 * Returns Lottie if available and smaller, otherwise WebP.
 *
 * @param metadata - Exercise animation metadata
 * @returns Preferred animation format
 *
 * @example
 * const format = getPreferredFormat(exerciseMeta);
 * if (format === 'lottie') {
 *   // Use LottieView
 * } else {
 *   // Use Image
 * }
 */
export function getPreferredFormat(
  metadata: ExerciseAnimationMetadata
): 'webp' | 'lottie' | null {
  if (!metadata.webp && !metadata.lottie) {
    return null;
  }

  // If only one format available, use it
  if (metadata.webp && !metadata.lottie) return 'webp';
  if (metadata.lottie && !metadata.webp) return 'lottie';

  // Both available - prefer smaller file
  const webpSize = metadata.webp!.file_size_bytes;
  const lottieSize = metadata.lottie!.file_size_bytes;

  return lottieSize < webpSize ? 'lottie' : 'webp';
}

export default AnimationManifest;
